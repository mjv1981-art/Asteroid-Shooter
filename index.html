<!doctype html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-07B5TZW10M"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-07B5TZW10M');
</script><!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-07B5TZW10M"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-07B5TZW10M');
</script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Space Shooter (Procrastination Build) — V2</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; outline: none; }

    :root {
      --fg: #fff;
      --dim: rgba(255,255,255,.65);
      --red: #ff2a2a;
      --redDim: rgba(255,42,42,.75);

      /* ZX-ish palette for border stripes */
      --zx0: #000000;
      --zx1: #0000d7; /* blue */
      --zx2: #d70000; /* red */
      --zx3: #d7d700; /* yellow */
      --zx4: #00d700; /* green */
      --zx5: #00d7d7; /* cyan */
      --zx6: #d700d7; /* magenta */
      --zx7: #d7d7d7; /* white-ish */
    }

    /* ===== Retro splash with ZX border stripes ===== */
    #splash-screen {
      position: fixed;
      inset: 0;
      z-index: 2000;
      cursor: pointer;
      display: grid;
      place-items: center;

      /* big Spectrum-like border area */
      padding: clamp(42px, 10vmin, 140px);

      /* striped border (tape-loader vibe) */
      background:
        repeating-linear-gradient(
          0deg,
          var(--zx2) 0px, var(--zx2) 6px,
          var(--zx3) 6px, var(--zx3) 12px,
          var(--zx4) 12px, var(--zx4) 18px,
          var(--zx5) 18px, var(--zx5) 24px,
          var(--zx1) 24px, var(--zx1) 30px,
          var(--zx6) 30px, var(--zx6) 36px,
          var(--zx7) 36px, var(--zx7) 42px,
          var(--zx0) 42px, var(--zx0) 50px
        );
      background-size: 100% 120px;
      animation: zxBorder 0.22s linear infinite;
      box-sizing: border-box;
    }

    @keyframes zxBorder {
      0% { background-position: 0 0; }
      100% { background-position: 0 120px; }
    }

    /* inner "screen" */
    .splash-inner {
      width: min(860px, 100%);
      aspect-ratio: 4 / 3;
      background: #000;
      border: 1px solid rgba(255,255,255,.25);
      box-shadow: 0 0 60px rgba(0,0,0,.55);

      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 18px;

      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    .brand {
      font-size: clamp(26px, 5vw, 56px);
      font-weight: 900;
      color: #ff0;
      text-shadow: 2px 2px 0 #f0f, 4px 4px 0 #0ff;
      letter-spacing: 6px;
      animation: flicker 2s infinite;
      user-select: none;
    }

    @keyframes flicker {
      0% { opacity: 1; }
      50% { opacity: 0.82; }
      100% { opacity: 1; }
    }

    .loader-text {
      font-size: clamp(16px, 3.6vw, 34px);
      color: #0f0;
      border-right: 2px solid #0f0;
      white-space: nowrap;
      overflow: hidden;
      padding-right: 6px;
      animation: blink-cursor 1s step-end infinite;
      user-select: none;
    }

    @keyframes blink-cursor {
      from, to { border-color: transparent; }
      50% { border-color: #0f0; }
    }

    .tape-bars {
      width: min(720px, 86%);
      height: 32px;
      background: repeating-linear-gradient(
        90deg,
        #0f0 0px,
        #0f0 10px,
        #000 10px,
        #000 20px
      );
      background-size: 200% 100%;
      animation: move-bars 0.5s linear infinite;
      opacity: 0.75;
      border: 1px solid rgba(0,255,0,.35);
      box-shadow: 0 0 18px rgba(0,255,0,.15);
    }

    @keyframes move-bars {
      0% { background-position: 0% 0%; }
      100% { background-position: 200% 0%; }
    }

    .click-hint {
      margin-top: 10px;
      font-size: clamp(12px, 2.6vw, 22px);
      color: rgba(255,255,255,.35);
      animation: pulse 1.5s infinite;
      user-select: none;
    }

    @keyframes pulse {
      0% { opacity: 0.25; }
      50% { opacity: 1; }
      100% { opacity: 0.25; }
    }

    /* Respect reduced motion */
    @media (prefers-reduced-motion: reduce) {
      #splash-screen { animation: none; }
      .tape-bars { animation: none; }
      .brand { animation: none; }
      .loader-text { animation: none; }
      .click-hint { animation: none; }
    }

    /* ===== HUD (top bar) ===== */
    .hud {
      position: fixed;
      top: 12px;
      left: 14px;
      right: 14px;
      z-index: 1200;
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      color: rgba(255,255,255,.85);
      pointer-events: none;
    }

    .hud .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 14px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.18);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    .pill.super .icon {
      width: 10px;
      height: 10px;
      border: 1px solid currentColor;
      display: inline-block;
    }

    .label { opacity: .7; }
    .kbd {
      font-size: 11px;
      opacity: .6;
    }

    .center {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #fff;
      font-family: ui-monospace, monospace;
      z-index: 1300;
    }

    /* Mobile / touch controls */
    .controls {
      position: fixed;
      left: 0; right: 0; bottom: 14px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      padding: 0 14px;
      gap: 12px;
      pointer-events: none; /* enable per-button */
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    .pad {
      display: flex;
      gap: 10px;
      pointer-events: none;
    }
    .btn {
      pointer-events: auto;
      width: 62px;
      height: 62px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.06);
      color: #fff;
      display: grid;
      place-items: center;
      font: 22px/1 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
    }
    .btn:active { transform: translateY(1px); }
    .btn.red {
      border-color: rgba(255,42,42,.45);
      background: rgba(255,42,42,.12);
      box-shadow: 0 10px 30px rgba(255,42,42,.08);
      color: #ff2a2a;
      font-weight: 900;
    }
    .btn.small {
      width: 56px; height: 56px;
      border-radius: 14px;
      font-size: 16px;
      color: rgba(255,255,255,.9);
    }
    .stack {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
      pointer-events: none;
    }
    .chip {
      pointer-events: auto;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.85);
      font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      pointer-events: auto;
    }
    .chip b { color: #fff; }
    .chip .r { color: #ff2a2a; }

    /* Slightly larger controls on very small screens */
    @media (max-width: 420px) {
      .btn { width: 66px; height: 66px; }
    }
  </style>
</head>
<body>
  <!-- Retro Waves / ZX tape loader splash -->
  <div id="splash-screen" role="button" aria-label="Retro Waves splash. Tap to start." tabindex="0">
    <div class="splash-inner">
      <div class="brand">RETRO WAVE</div>
      <div class="loader-text" id="loading-text">LOADING...</div>
      <div class="tape-bars"></div>
      <div class="click-hint">> TAP / CLICK TO START TAPE <</div>
    </div>
  </div>

  <canvas id="c" tabindex="0" aria-label="Space shooter canvas"></canvas>

  <div class="hud">
    <div class="row">
      <span class="pill"><span class="label">Score</span> <b id="hudScore">0</b></span>
      <span class="pill"><span class="label">Stage</span> <b id="hudStage">1</b></span>
    </div>

    <div class="row">
      <span class="pill super" id="fanPill" style="display:none;">
        <span class="icon red" aria-hidden="true"></span>
        <span class="label">Fan</span>
        <b id="hudFan">0</b>
        <span class="kbd">(Space)</span>
      </span>

      <span class="pill super" id="spherePill" style="display:none;">
        <span class="icon red" aria-hidden="true" style="border-radius:999px;"></span>
        <span class="label">Sphere</span>
        <b id="hudSphere">0</b>
        <span class="kbd">(Enter)</span>
      </span>
    </div>

    <div class="row" style="margin-top:6px;">
      <span class="label">Rotate:</span> <span class="kbd">← / →</span>
      <span class="label">Auto-fire:</span> <span class="kbd">ON</span>
      <span class="label">Restart:</span> <span class="kbd">Enter (after death)</span>
    </div>
  </div>

  <div id="overlay" class="center" style="display:none;"></div>

  <!-- Touch controls (mobile-friendly) -->
  <div class="controls" id="controls" aria-hidden="false">
    <div class="pad">
      <button class="btn" id="btnLeft" aria-label="Rotate left">⟲</button>
      <button class="btn" id="btnRight" aria-label="Rotate right">⟳</button>
    </div>

    <div class="stack">
      <div class="chip" id="chipHelp"><span>Touch:</span> <span class="r">Fan</span><span>=</span><b>F</b> <span class="r">Sphere</span><span>=</span><b>S</b></div>
      <div class="pad" style="justify-content:flex-end;">
        <button class="btn red small" id="btnFan" aria-label="Fire Fan Cannon" style="display:none;">F</button>
        <button class="btn red small" id="btnSphere" aria-label="Fire Sphere Cannon" style="display:none;">S</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Retro splash logic (ZX tape loader) =====
  const splash = document.getElementById('splash-screen');
  const loadingText = document.getElementById('loading-text');

  let gameStarted = false;

  function playTapeSound() {
    // short synthesized tape noise/tones (no external assets)
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    // Volume control (~19% loudness)
    const gain = audioCtx.createGain();
    gain.gain.value = 0.19;
    if (audioCtx.state === 'suspended') audioCtx.resume();

    const duration = 3.6;
    const sampleRate = audioCtx.sampleRate;
    const buffer = audioCtx.createBuffer(1, sampleRate * duration, sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < buffer.length; i++) {
      const t = i / sampleRate;
      let sample = 0;

      if (t < 0.5) {
        sample = Math.random() * 0.28 - 0.14;
      } else if (t < 1.5) {
        sample = Math.sin(2 * Math.PI * 2000 * t) * 0.35 + (Math.random() * 0.1 - 0.05);
      } else if (t < 2.6) {
        const freq = (Math.sin(2 * Math.PI * 18 * t) > 0) ? 1500 : 2500;
        sample = Math.sin(2 * Math.PI * freq * t) * 0.36 + (Math.random() * 0.18 - 0.09);
      } else {
        const decay = 1 - (t - 2.6) / 1.0;
        sample = Math.sin(2 * Math.PI * 1600 * t) * 0.22 * decay;
      }

      sample += (Math.random() * 0.08 - 0.04) * (1 - t / duration);
      data[i] = Math.max(-1, Math.min(1, sample));
    }

    const source = audioCtx.createBufferSource();
    source.buffer = buffer;
    source.connect(gain);
    gain.connect(audioCtx.destination);
    source.start();

    source.onended = () => {
      try { audioCtx.close(); } catch {}
    };
  }

  function startSplashSequence() {
    if (gameStarted) return;
    gameStarted = true;

    loadingText.textContent = '> TAPE LOADING... <';
    playTapeSound();

    let dots = 0;
    const interval = setInterval(() => {
      dots = (dots + 1) % 4;
      loadingText.textContent = '> TAPE LOADING' + '.'.repeat(dots) + ' <';
    }, 300);

    setTimeout(() => {
      clearInterval(interval);
      splash.style.display = 'none';
      // kick off the game loop
      startGame();
    }, 3600);
  }

  // Start on click/tap/enter
  splash.addEventListener('click', startSplashSequence);
  splash.addEventListener('pointerdown', (e) => { e.preventDefault(); startSplashSequence(); }, { passive: false });
  splash.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      startSplashSequence();
    }
  });

  // ===== Canvas setup =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas._dpr = dpr;
  }
  window.addEventListener('resize', resize);
  resize();

  // ===== HUD refs =====
  const hudScore = document.getElementById('hudScore');
  const hudStage = document.getElementById('hudStage');
  const hudFan = document.getElementById('hudFan');
  const hudSphere = document.getElementById('hudSphere');
  const fanPill = document.getElementById('fanPill');
  const spherePill = document.getElementById('spherePill');

  // Touch controls
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnFan = document.getElementById('btnFan');
  const btnSphere = document.getElementById('btnSphere');
  const chipHelp = document.getElementById('chipHelp');

  // ===== Helpers =====
  const TAU = Math.PI * 2;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  function rand(min, max) { return min + Math.random() * (max - min); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  // A tiny deterministic-ish random seed for asteroid shapes
  function hash(n) {
    n = (n ^ 61) ^ (n >>> 16);
    n = n + (n << 3);
    n = n ^ (n >>> 4);
    n = n * 0x27d4eb2d;
    n = n ^ (n >>> 15);
    return n >>> 0;
  }

  function stageFromScore(score) {
    if (score >= 200) return 3;
    if (score >= 100) return 2;
    return 1;
  }

  function asteroidClassFromRadius(r) {
    // Tuned for our current spawn range ~[18..72]
    // small  : < 30  => 5 pts
    // medium : < 50  => 3 pts
    // big    : >=50  => 1 pt
    if (r < 30) return { kind: 'small', pts: 5 };
    if (r < 50) return { kind: 'medium', pts: 3 };
    return { kind: 'big', pts: 1 };
  }

  // ===== Game state =====
  const overlay = document.getElementById('overlay');
  const keys = new Set();

  // In embedded previews, the iframe/canvas may not have keyboard focus.
  // Make the canvas focusable and always re-focus on click/tap.
  canvas.tabIndex = 0;
  const focusCanvas = () => { try { canvas.focus({ preventScroll: true }); } catch { canvas.focus(); } };
  window.addEventListener('pointerdown', focusCanvas);
  canvas.addEventListener('pointerdown', focusCanvas);
  window.addEventListener('touchstart', focusCanvas, { passive: true });
  focusCanvas();

  const normKey = (e) => {
    const k = e.key;
    if (k === 'ArrowLeft' || k === 'Left') return 'ArrowLeft';
    if (k === 'ArrowRight' || k === 'Right') return 'ArrowRight';
    if (k === 'ArrowUp' || k === 'Up') return 'ArrowUp';
    if (k === 'ArrowDown' || k === 'Down') return 'ArrowDown';
    if (k === ' ') return 'Space';
    return k;
  };

  const onKeyDown = (e) => {
    const k = normKey(e);
    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Space","Enter"].includes(k)) e.preventDefault();

    // Fire super weapons on keydown (single press), not while held
    if (!e.repeat) {
      if (!state.gameOver && k === 'Space') fireFanCannon();
      if (!state.gameOver && k === 'Enter') fireSphereCannon();
      if (state.gameOver && k === 'Enter') reset();
    }

    keys.add(k);
  };

  const onKeyUp = (e) => {
    const k = normKey(e);
    keys.delete(k);
  };

  window.addEventListener('keydown', onKeyDown, { passive: false });
  window.addEventListener('keyup', onKeyUp);
  document.addEventListener('keydown', onKeyDown, { passive: false });
  document.addEventListener('keyup', onKeyUp);
  canvas.addEventListener('keydown', onKeyDown, { passive: false });
  canvas.addEventListener('keyup', onKeyUp);
  window.addEventListener('focus', focusCanvas);
  document.addEventListener('visibilitychange', () => { if (!document.hidden) focusCanvas(); });

  // ===== Touch input helpers =====
  const bindHold = (el, keyName) => {
    const down = (e) => {
      e.preventDefault();
      focusCanvas();
      keys.add(keyName);
    };
    const up = (e) => {
      e.preventDefault();
      keys.delete(keyName);
    };

    el.addEventListener('pointerdown', down, { passive: false });
    window.addEventListener('pointerup', up, { passive: false });
    window.addEventListener('pointercancel', up, { passive: false });
    el.addEventListener('pointerleave', up, { passive: false });
  };

  bindHold(btnLeft, 'ArrowLeft');
  bindHold(btnRight, 'ArrowRight');

  const bindTap = (el, fn) => {
    const tap = (e) => {
      e.preventDefault();
      focusCanvas();
      fn();
    };
    el.addEventListener('pointerdown', tap, { passive: false });
  };

  bindTap(btnFan, () => { if (!state.gameOver) fireFanCannon(); });
  bindTap(btnSphere, () => { if (!state.gameOver) fireSphereCannon(); });

  // Also support a very simple gesture fallback:
  // drag left/right anywhere = rotate; release = stop.
  let gestureActive = false;
  let gestureStartX = 0;
  let gesturePointerId = null;

  const onGestureDown = (e) => {
    // If the user touched a button, ignore (buttons already handle it)
    if (e.target === btnLeft || e.target === btnRight || e.target === btnFan || e.target === btnSphere) return;
    gestureActive = true;
    gestureStartX = e.clientX;
    gesturePointerId = e.pointerId;
  };

  const onGestureMove = (e) => {
    if (!gestureActive || e.pointerId !== gesturePointerId) return;
    const dx = e.clientX - gestureStartX;
    const dead = 10;
    keys.delete('ArrowLeft');
    keys.delete('ArrowRight');
    if (dx > dead) keys.add('ArrowRight');
    else if (dx < -dead) keys.add('ArrowLeft');
  };

  const onGestureUp = (e) => {
    if (!gestureActive || e.pointerId !== gesturePointerId) return;
    gestureActive = false;
    gesturePointerId = null;
    keys.delete('ArrowLeft');
    keys.delete('ArrowRight');
  };

  canvas.addEventListener('pointerdown', onGestureDown, { passive: true });
  canvas.addEventListener('pointermove', onGestureMove, { passive: true });
  window.addEventListener('pointerup', onGestureUp, { passive: true });
  window.addEventListener('pointercancel', onGestureUp, { passive: true });

  const state = {
    t: 0,
    last: performance.now(),
    gameOver: false,
    score: 0,
    stage: 1,

    // ship sits in the center - player controls aiming via rotation.
    ship: {
      angle: -Math.PI / 2,
      angVel: 0,
      rotAcc: 10.0,       // rad/s^2
      rotDamp: 10.0,      // higher = more damping
      radius: 16,
      fireRate: 14,       // bullets per second (auto-fire)
      fireTimer: 0,
    },

    bullets: [],
    asteroids: [],
    particles: [],

    super: {
      fanAmmo: 0,
      sphereAmmo: 0,
      awarded100: false,
      awarded140: false,
      awarded180: false,
      awarded200: false,
      infiniteUnlocked: false,
    },

    // difficulty pacing
    spawnTimer: 0,
    spawnEvery: 0.75,
    maxAsteroids: 14,
  };

  function reset() {
    state.t = 0;
    state.last = performance.now();
    state.gameOver = false;

    state.score = 0;
    state.stage = 1;

    state.bullets.length = 0;
    state.asteroids.length = 0;
    state.particles.length = 0;

    state.spawnTimer = 0;
    state.spawnEvery = 0.75;
    state.maxAsteroids = 14;

    state.ship.angle = -Math.PI / 2;
    state.ship.angVel = 0;
    state.ship.fireTimer = 0;

    state.super.fanAmmo = 0;
    state.super.sphereAmmo = 0;
    state.super.awarded100 = false;
    state.super.awarded140 = false;
    state.super.awarded180 = false;
    state.super.awarded200 = false;
    state.super.infiniteUnlocked = false;

    overlay.style.display = 'none';
    syncHud();
  }

  function gameOver() {
    state.gameOver = true;
    overlay.style.display = 'block';
    overlay.innerHTML = `
      <h1>GAME OVER</h1>
      <p>Hit by an asteroid.</p>
      <p style="margin-top:10px; opacity:.75;">Press <b>Enter</b> to restart</p>
    `;
  }

  function syncHud() {
    hudScore.textContent = String(state.score);
    hudStage.textContent = String(state.stage);

    const infinite = state.super.infiniteUnlocked;

    // Fan appears starting Stage 2
    if (state.stage >= 2) {
      fanPill.style.display = 'inline-flex';
      hudFan.textContent = infinite ? '∞' : String(state.super.fanAmmo);
      btnFan.style.display = 'inline-grid';
    } else {
      fanPill.style.display = 'none';
      btnFan.style.display = 'none';
    }

    // Sphere appears starting Stage 3
    if (state.stage >= 3) {
      spherePill.style.display = 'inline-flex';
      hudSphere.textContent = infinite ? '∞' : String(state.super.sphereAmmo);
      btnSphere.style.display = 'inline-grid';
    } else {
      spherePill.style.display = 'none';
      btnSphere.style.display = 'none';
    }

    // If a super is empty, dim the corresponding touch button (unless infinite)
    btnFan.style.opacity = (state.stage >= 2 && (infinite || state.super.fanAmmo > 0)) ? '1' : '0.35';
    btnSphere.style.opacity = (state.stage >= 3 && (infinite || state.super.sphereAmmo > 0)) ? '1' : '0.35';
  }

  // ===== Procedural asteroid =====
  function makeAsteroidShape(seed, verts) {
    const arr = [];
    let s = seed;
    for (let i = 0; i < verts; i++) {
      s = hash(s + i * 1013904223);
      const r = 0.78 + ((s % 1000) / 1000) * 0.44; // ~[0.78..1.22]
      arr.push(r);
    }
    return arr;
  }

  function spawnAsteroid() {
    const w = canvas.width / canvas._dpr;
    const h = canvas.height / canvas._dpr;

    const edge = Math.floor(rand(0, 4));
    let x, y;
    const margin = 60;
    if (edge === 0) { x = rand(-margin, w + margin); y = -margin; }
    if (edge === 1) { x = w + margin; y = rand(-margin, h + margin); }
    if (edge === 2) { x = rand(-margin, w + margin); y = h + margin; }
    if (edge === 3) { x = -margin; y = rand(-margin, h + margin); }

    const cx = w * 0.5;
    const cy = h * 0.5;
    const toCenter = Math.atan2(cy - y, cx - x);
    const dir = toCenter + rand(-0.9, 0.9);

    const size = rand(18, 72);
    const speed = rand(55, 165) * (0.9 + (72 / size) * 0.25);

    const seed = (Math.random() * 1e9) | 0;
    const verts = Math.floor(rand(8, 14));
    const shape = makeAsteroidShape(seed, verts);

    state.asteroids.push({
      x, y,
      vx: Math.cos(dir) * speed,
      vy: Math.sin(dir) * speed,
      r: size,
      verts,
      shape,
      rot: rand(0, TAU),
      rotSpd: rand(-1.2, 1.2),
      seed,
      // approximate collision radius
      hitR: size * 0.88,
    });
  }

  // ===== Bullets / particles =====
  function spawnBullet(x, y, angle, speed, opts = {}) {
    state.bullets.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 0,
      maxLife: opts.maxLife ?? 1.1,
      tx: x, ty: y,
      // rendering
      color: opts.color ?? '#fff',
      width: opts.width ?? 1.6,
      dot: opts.dot ?? 1.7,
      trailBase: opts.trailBase ?? 18,
      trailExtra: opts.trailExtra ?? 22,
      isSuper: !!opts.isSuper,
    });
  }

  function shootRegular() {
    const w = canvas.width / canvas._dpr;
    const h = canvas.height / canvas._dpr;
    const s = state.ship;
    const cx = w * 0.5;
    const cy = h * 0.5;

    const muzzle = s.radius + 10;
    const speed = 620;

    if (state.stage < 3) {
      // Stage 1–2: Single trace
      const px = cx + Math.cos(s.angle) * muzzle;
      const py = cy + Math.sin(s.angle) * muzzle;
      spawnBullet(px, py, s.angle, speed);
      return;
    }

    // Stage 3: Triple trace (+2 from wings)
    // Center
    spawnBullet(
      cx + Math.cos(s.angle) * muzzle,
      cy + Math.sin(s.angle) * muzzle,
      s.angle,
      speed
    );

    // Wings: same heading, slight lateral offset
    const wing = 11;
    const nx = -Math.sin(s.angle);
    const ny = Math.cos(s.angle);

    spawnBullet(
      cx + Math.cos(s.angle) * (muzzle - 2) + nx * wing,
      cy + Math.sin(s.angle) * (muzzle - 2) + ny * wing,
      s.angle,
      speed
    );
    spawnBullet(
      cx + Math.cos(s.angle) * (muzzle - 2) - nx * wing,
      cy + Math.sin(s.angle) * (muzzle - 2) - ny * wing,
      s.angle,
      speed
    );
  }

  function fireFanCannon() {
    if (state.stage < 2) return;
    if (!state.super.infiniteUnlocked && state.super.fanAmmo <= 0) return;

    if (!state.super.infiniteUnlocked) state.super.fanAmmo -= 1;

    const w = canvas.width / canvas._dpr;
    const h = canvas.height / canvas._dpr;
    const s = state.ship;
    const cx = w * 0.5;
    const cy = h * 0.5;

    // Visual idea: wing cannons, spread forward like a fan
    const muzzle = s.radius + 12;
    const speed = 720;
    const color = '#ff2a2a';

    const wing = 13;
    const nx = -Math.sin(s.angle);
    const ny = Math.cos(s.angle);

    // 7 projectiles in a forward arc
    const n = 7;
    const spread = 0.55; // radians total arc
    for (let i = 0; i < n; i++) {
      const t = (i / (n - 1)) * 2 - 1; // [-1..1]
      const a = s.angle + t * (spread / 2);

      // alternate between left/right wing muzzle origins for a nice feel
      const side = (i % 2 === 0) ? 1 : -1;
      const ox = nx * wing * side;
      const oy = ny * wing * side;

      const px = cx + Math.cos(s.angle) * muzzle + ox;
      const py = cy + Math.sin(s.angle) * muzzle + oy;

      spawnBullet(px, py, a, speed, {
        color,
        width: 2.2,
        dot: 2.0,
        trailBase: 22,
        trailExtra: 34,
        maxLife: 1.0,
        isSuper: true,
      });
    }

    syncHud();
  }

  function fireSphereCannon() {
    if (state.stage < 3) return;
    if (!state.super.infiniteUnlocked && state.super.sphereAmmo <= 0) return;

    if (!state.super.infiniteUnlocked) state.super.sphereAmmo -= 1;

    const w = canvas.width / canvas._dpr;
    const h = canvas.height / canvas._dpr;
    const s = state.ship;
    const cx = w * 0.5;
    const cy = h * 0.5;

    const speed = 640;
    const color = '#ff2a2a';

    // 16 projectiles in a full circle
    const n = 16;
    for (let i = 0; i < n; i++) {
      const a = (i / n) * TAU;
      const px = cx + Math.cos(a) * (s.radius + 8);
      const py = cy + Math.sin(a) * (s.radius + 8);
      spawnBullet(px, py, a, speed, {
        color,
        width: 2.2,
        dot: 2.0,
        trailBase: 18,
        trailExtra: 30,
        maxLife: 1.05,
        isSuper: true,
      });
    }

    syncHud();
  }

  function explode(x, y, baseR, tint = '#fff') {
    const count = Math.floor(clamp(baseR * 0.65, 10, 44));
    for (let i = 0; i < count; i++) {
      const a = rand(0, TAU);
      const sp = rand(80, 520) * (0.65 + Math.random() * 0.7);
      const len = rand(6, 24);
      state.particles.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        life: 0,
        maxLife: rand(0.25, 0.65),
        len,
        color: tint,
      });
    }
  }

  // ===== Collision =====
  function dist2(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
  }

  function awardSuperAmmo() {
    // Unlock infinite supers at 300 score
    if (!state.super.infiniteUnlocked && state.score >= 300) {
      state.super.infiniteUnlocked = true;
      state.super.fanAmmo = 9999;
      state.super.sphereAmmo = 9999;
    }

    // If infinite already unlocked, skip normal ammo progression
    if (state.super.infiniteUnlocked) return;

    // Fan cannon charges: +1 at 100, +1 at 140, +1 at 180 (retainable)
    if (!state.super.awarded100 && state.score >= 100) { state.super.awarded100 = true; state.super.fanAmmo += 1; }
    if (!state.super.awarded140 && state.score >= 140) { state.super.awarded140 = true; state.super.fanAmmo += 1; }
    if (!state.super.awarded180 && state.score >= 180) { state.super.awarded180 = true; state.super.fanAmmo += 1; }

    // Sphere cannon charges: +1 at 200
    if (!state.super.awarded200 && state.score >= 200) { state.super.awarded200 = true; state.super.sphereAmmo += 1; }
  }

  // ===== Update / draw =====
  function update(dt) {
    const w = canvas.width / canvas._dpr;
    const h = canvas.height / canvas._dpr;

    state.t += dt;

    // ship rotation physics
    const s = state.ship;
    const left = keys.has('ArrowLeft');
    const right = keys.has('ArrowRight');
    let input = 0;
    if (left) input -= 1;
    if (right) input += 1;

    s.angVel += input * s.rotAcc * dt;
    s.angVel *= Math.exp(-s.rotDamp * dt);
    s.angle += s.angVel * dt;

    // auto-fire regular weapon
    s.fireTimer += dt;
    const interval = 1 / s.fireRate;
    while (!state.gameOver && s.fireTimer >= interval) {
      s.fireTimer -= interval;
      shootRegular();
    }

    // spawn asteroids with gentle difficulty ramp
    state.spawnTimer += dt;
    state.spawnEvery = clamp(lerp(0.85, 0.45, Math.min(1, state.t / 70)), 0.42, 0.9);
    state.maxAsteroids = Math.floor(lerp(10, 18, Math.min(1, state.t / 80)));

    while (!state.gameOver && state.spawnTimer >= state.spawnEvery) {
      state.spawnTimer -= state.spawnEvery;
      if (state.asteroids.length < state.maxAsteroids) spawnAsteroid();
    }

    // bullets
    for (let i = state.bullets.length - 1; i >= 0; i--) {
      const b = state.bullets[i];
      b.life += dt;
      b.tx = b.x;
      b.ty = b.y;
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      const pad = 80;
      if (b.life > b.maxLife || b.x < -pad || b.x > w + pad || b.y < -pad || b.y > h + pad) {
        state.bullets.splice(i, 1);
      }
    }

    // asteroids
    for (let i = state.asteroids.length - 1; i >= 0; i--) {
      const a = state.asteroids[i];
      a.x += a.vx * dt;
      a.y += a.vy * dt;
      a.rot += a.rotSpd * dt;

      const pad = 140;
      if (a.x < -pad || a.x > w + pad || a.y < -pad || a.y > h + pad) {
        state.asteroids.splice(i, 1);
      }
    }

    // particles
    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      p.life += dt;
      const damp = Math.exp(-3.4 * dt);
      p.vx *= damp;
      p.vy *= damp;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.life >= p.maxLife) state.particles.splice(i, 1);
    }

    // collisions: bullets vs asteroids
    for (let ai = state.asteroids.length - 1; ai >= 0; ai--) {
      const a = state.asteroids[ai];
      const hr2 = (a.hitR) * (a.hitR);
      let hit = false;
      for (let bi = state.bullets.length - 1; bi >= 0; bi--) {
        const b = state.bullets[bi];
        if (dist2(a.x, a.y, b.x, b.y) <= hr2) {
          state.bullets.splice(bi, 1);
          hit = true;
          break;
        }
      }

      if (hit) {
        const cls = asteroidClassFromRadius(a.r);
        state.score += cls.pts;

        // stage transitions are score-based
        const newStage = stageFromScore(state.score);
        if (newStage !== state.stage) {
          state.stage = newStage;
        }

        awardSuperAmmo();
        explode(a.x, a.y, a.r, '#fff');
        state.asteroids.splice(ai, 1);

        syncHud();
      }
    }

    // ship collision (one life)
    if (!state.gameOver) {
      const cx = w * 0.5;
      const cy = h * 0.5;
      const shipR = state.ship.radius;

      for (let ai = 0; ai < state.asteroids.length; ai++) {
        const a = state.asteroids[ai];
        const rr = (a.hitR + shipR * 0.85);
        if (dist2(cx, cy, a.x, a.y) <= rr * rr) {
          explode(cx, cy, 55, '#fff');
          gameOver();
          break;
        }
      }
    }
  }

  function drawShip(stage) {
    // ship is drawn around origin, facing +X (we rotate canvas to angle)
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;

    if (stage === 1) {
      // Simple dart
      ctx.beginPath();
      ctx.moveTo(20, 0);
      ctx.lineTo(-14, -12);
      ctx.lineTo(-6, 0);
      ctx.lineTo(-14, 12);
      ctx.closePath();
      ctx.stroke();
      return;
    }

    if (stage === 2) {
      // Jet fighter silhouette (F-16-ish vibe, still simple line art)
      // fuselage + nose
      ctx.beginPath();
      ctx.moveTo(24, 0);        // nose
      ctx.lineTo(10, -4);
      ctx.lineTo(-6, -6);
      ctx.lineTo(-18, -2);
      ctx.lineTo(-24, 0);       // tail center
      ctx.lineTo(-18, 2);
      ctx.lineTo(-6, 6);
      ctx.lineTo(10, 4);
      ctx.closePath();
      ctx.stroke();

      // main wings (swept)
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      ctx.moveTo(4, -4);
      ctx.lineTo(-6, -18);
      ctx.lineTo(-2, -4);
      ctx.moveTo(4, 4);
      ctx.lineTo(-6, 18);
      ctx.lineTo(-2, 4);
      ctx.stroke();

      // tail fins
      ctx.globalAlpha = 0.65;
      ctx.lineWidth = 1.4;
      ctx.beginPath();
      ctx.moveTo(-16, -1);
      ctx.lineTo(-22, -10);
      ctx.moveTo(-16, 1);
      ctx.lineTo(-22, 10);
      ctx.stroke();

      // cockpit line
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.moveTo(12, 0);
      ctx.lineTo(4, 0);
      ctx.stroke();

      ctx.globalAlpha = 1;
      ctx.lineWidth = 2;
      return;
    }

    // stage 3: X-wing-inspired silhouette (iconic "X" wings + nacelle hints)
    // central fuselage
    ctx.beginPath();
    ctx.moveTo(24, 0);       // nose
    ctx.lineTo(12, -3);
    ctx.lineTo(-10, -3);
    ctx.lineTo(-22, 0);      // rear
    ctx.lineTo(-10, 3);
    ctx.lineTo(12, 3);
    ctx.closePath();
    ctx.stroke();

    // S-foils (four wings forming an X)
    ctx.lineWidth = 1.7;
    ctx.beginPath();
    // upper pair
    ctx.moveTo(6, -4);
    ctx.lineTo(-14, -18);
    ctx.moveTo(6, -4);
    ctx.lineTo(-14, 18);
    // lower pair
    ctx.moveTo(6, 4);
    ctx.lineTo(-14, -18);
    ctx.moveTo(6, 4);
    ctx.lineTo(-14, 18);
    ctx.stroke();

    // engine/nacelle hints near wing tips
    ctx.globalAlpha = 0.75;
    ctx.lineWidth = 1.2;
    const nac = (x, y) => {
      ctx.beginPath();
      ctx.moveTo(x - 2, y - 2);
      ctx.lineTo(x + 4, y - 2);
      ctx.lineTo(x + 4, y + 2);
      ctx.lineTo(x - 2, y + 2);
      ctx.closePath();
      ctx.stroke();
    };
    nac(-14, -18);
    nac(-14, 18);

    // cockpit line
    ctx.globalAlpha = 0.55;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(13, 0);
    ctx.lineTo(5, 0);
    ctx.stroke();

    ctx.globalAlpha = 1;
    ctx.lineWidth = 2;
  }

  function draw() {
    const dpr = canvas._dpr || 1;
    const w = canvas.width / dpr;
    const h = canvas.height / dpr;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, w, h);

    // ===== Cinematic starfield background =====
    // Deep space gradient
    const g = ctx.createRadialGradient(w*0.5, h*0.5, 0, w*0.5, h*0.5, Math.max(w,h)*0.7);
    g.addColorStop(0, '#05070d');
    g.addColorStop(0.6, '#020309');
    g.addColorStop(1, '#000000');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, w, h);

    // Star layers (parallax illusion via slight vertical drift over time)
    const t = state.t;

    const drawStars = (count, sizeMin, sizeMax, alpha, speedFactor) => {
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < count; i++) {
        // deterministic pseudo positions
        const sx = (Math.sin(i * 127.1) * 0.5 + 0.5) * w;
        const baseY = (Math.sin(i * 311.7) * 0.5 + 0.5) * h;
        const sy = (baseY + t * speedFactor) % h;

        const twinkle = 0.5 + 0.5 * Math.sin(t * 2 + i);
        const size = sizeMin + (sizeMax - sizeMin) * twinkle;

        ctx.fillRect(sx, sy, size, size);
      }
    };

    // Far faint stars
    drawStars(Math.floor((w*h)/45000), 0.5, 1.2, 0.35, 4);
    // Mid layer
    drawStars(Math.floor((w*h)/65000), 0.8, 1.6, 0.55, 8);
    // Near bright stars
    drawStars(Math.floor((w*h)/120000), 1.2, 2.4, 0.9, 14);

    ctx.globalAlpha = 1;

    // bullets (with traces)
    for (const b of state.bullets) {
      const t = b.life / b.maxLife;
      const trail = b.trailBase + b.trailExtra * (1 - t);
      const dx = b.x - b.tx;
      const dy = b.y - b.ty;
      const mag = Math.hypot(dx, dy) || 1;
      const ux = dx / mag;
      const uy = dy / mag;

      ctx.globalAlpha = 0.95;
      ctx.lineWidth = b.width;
      ctx.strokeStyle = b.color;
      ctx.beginPath();
      ctx.moveTo(b.x - ux * trail, b.y - uy * trail);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();

      ctx.globalAlpha = 1;
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.dot, 0, TAU);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // particles
    for (const p of state.particles) {
      const t = clamp(p.life / p.maxLife, 0, 1);
      const a = 1 - t;
      ctx.globalAlpha = a;
      ctx.lineWidth = 1.4;
      const ang = Math.atan2(p.vy, p.vx);
      const x2 = p.x - Math.cos(ang) * p.len;
      const y2 = p.y - Math.sin(ang) * p.len;
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(p.x, p.y);
      ctx.strokeStyle = p.color || '#fff';
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // asteroids
    for (const a of state.asteroids) {
      ctx.save();
      ctx.translate(a.x, a.y);
      ctx.rotate(a.rot);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < a.verts; i++) {
        const ang = (i / a.verts) * TAU;
        const rr = a.r * a.shape[i];
        const x = Math.cos(ang) * rr;
        const y = Math.sin(ang) * rr;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();

      ctx.globalAlpha = 0.25;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-a.r * 0.35, -a.r * 0.1);
      ctx.lineTo(a.r * 0.15, a.r * 0.22);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // ship (center)
    const cx = w * 0.5;
    const cy = h * 0.5;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(state.ship.angle);

    drawShip(state.stage);

    // faint engine line
    ctx.globalAlpha = 0.35;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-18, 0);
    ctx.lineTo(-30, 0);
    ctx.strokeStyle = '#fff';
    ctx.stroke();
    ctx.globalAlpha = 1;

    ctx.restore();

    // game over vignette
    if (state.gameOver) {
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 1;
    }
  }

  function tick(now) {
    const dt = clamp((now - state.last) / 1000, 0, 0.033);
    state.last = now;

    if (!state.gameOver) update(dt);
    else {
      // still update particles for a pleasant finish
      for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        p.life += dt;
        const damp = Math.exp(-3.4 * dt);
        p.vx *= damp;
        p.vy *= damp;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.life >= p.maxLife) state.particles.splice(i, 1);
      }
    }

    draw();
    requestAnimationFrame(tick);
  }

  // NOTE: Game now starts after the splash screen.
  function startGame() {
    reset();
    requestAnimationFrame((t) => { state.last = t; requestAnimationFrame(tick); });
  }

  // If someone disables the splash via devtools, allow game start.
  // (We don't auto-start here so the branding screen always shows first.)
})();
</script>
</body>
</html>
