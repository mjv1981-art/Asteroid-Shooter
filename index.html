<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2D Space Shooter (Procrastination Build)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { display: block; width: 100vw; height: 100vh; outline: none; }
    .hud {
      position: fixed; left: 14px; top: 12px;
      color: #fff; font: 14px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      opacity: 0.9; user-select: none;
      text-shadow: 0 0 10px rgba(255,255,255,.15);
    }
    .hud .dim { opacity: 0.65; }
    .center {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
      color: #fff; text-align: center;
      font: 16px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select: none;
    }
    .center h1 { margin: 0 0 8px; font-size: 22px; font-weight: 800; letter-spacing: 0.5px; }
    .center p { margin: 0; opacity: 0.85; }
  </style>
</head>
<body>
  <canvas id="c" tabindex="0" aria-label="Space shooter canvas"></canvas>
  <div class="hud">
    <div><b>Controls</b></div>
    <div class="dim">← / → rotate</div>
    <div class="dim">Auto-fire is ON</div>
    <div class="dim">Enter = restart</div>
  </div>
  <div id="overlay" class="center" style="display:none;"></div>

<script>
(() => {
  // ===== Canvas setup =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas._dpr = dpr;
  }
  window.addEventListener('resize', resize);
  resize();

  // ===== Helpers =====
  const TAU = Math.PI * 2;
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  function rand(min, max) { return min + Math.random() * (max - min); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  // A tiny deterministic-ish random seed for asteroid shapes
  function hash(n) {
    // simple integer hash
    n = (n ^ 61) ^ (n >>> 16);
    n = n + (n << 3);
    n = n ^ (n >>> 4);
    n = n * 0x27d4eb2d;
    n = n ^ (n >>> 15);
    return n >>> 0;
  }

  // ===== Game state =====
  const overlay = document.getElementById('overlay');
  const keys = new Set();

  // In embedded previews, the iframe/canvas may not have keyboard focus.
  // Make the canvas focusable and always re-focus on click/tap.
  canvas.tabIndex = 0;
  const focusCanvas = () => { try { canvas.focus({ preventScroll: true }); } catch { canvas.focus(); } };
  window.addEventListener('pointerdown', focusCanvas);
  canvas.addEventListener('pointerdown', focusCanvas);
  window.addEventListener('touchstart', focusCanvas, { passive: true });
  focusCanvas();

  const normKey = (e) => {
    // support both modern and older key values
    const k = e.key;
    if (k === 'ArrowLeft' || k === 'Left') return 'ArrowLeft';
    if (k === 'ArrowRight' || k === 'Right') return 'ArrowRight';
    if (k === 'ArrowUp' || k === 'Up') return 'ArrowUp';
    if (k === 'ArrowDown' || k === 'Down') return 'ArrowDown';
    return k;
  };

  const onKeyDown = (e) => {
    const k = normKey(e);
    // prevent page scrolling / navigation
    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"," "].includes(k)) e.preventDefault();
    keys.add(k);
    if (k === 'Enter' && state.gameOver) reset();
  };

  const onKeyUp = (e) => {
    const k = normKey(e);
    keys.delete(k);
  };

  // Listen on multiple targets for reliability across environments
  window.addEventListener('keydown', onKeyDown, { passive: false });
  window.addEventListener('keyup', onKeyUp);
  document.addEventListener('keydown', onKeyDown, { passive: false });
  document.addEventListener('keyup', onKeyUp);
  canvas.addEventListener('keydown', onKeyDown, { passive: false });
  canvas.addEventListener('keyup', onKeyUp);

  // If focus is lost (e.g., click elsewhere), arrows may stop working.
  // Reacquire focus when the window regains it.
  window.addEventListener('focus', focusCanvas);
  document.addEventListener('visibilitychange', () => { if (!document.hidden) focusCanvas(); });

  const state = {
    t: 0,
    last: performance.now(),
    gameOver: false,
    // ship sits in the center (as requested) - player controls aiming via rotation.
    ship: {
      x: 0, y: 0,
      angle: -Math.PI / 2,
      angVel: 0,
      rotAcc: 10.0,       // rad/s^2 - snappy but smooth
      rotDamp: 10.0,      // higher = more damping
      radius: 16,
      fireRate: 14,       // bullets per second (auto-fire)
      fireTimer: 0,
    },
    bullets: [],
    asteroids: [],
    particles: [],
    // difficulty pacing
    spawnTimer: 0,
    spawnEvery: 0.75,
    maxAsteroids: 14,
  };

  function reset() {
    state.t = 0;
    state.last = performance.now();
    state.gameOver = false;
    state.bullets.length = 0;
    state.asteroids.length = 0;
    state.particles.length = 0;
    state.spawnTimer = 0;
    state.spawnEvery = 0.75;
    state.maxAsteroids = 14;
    state.ship.angle = -Math.PI / 2;
    state.ship.angVel = 0;
    state.ship.fireTimer = 0;
    overlay.style.display = 'none';
  }

  function gameOver() {
    state.gameOver = true;
    overlay.style.display = 'block';
    overlay.innerHTML = `
      <h1>GAME OVER</h1>
      <p>Hit by an asteroid.</p>
      <p style="margin-top:10px; opacity:.75;">Press <b>Enter</b> to restart</p>
    `;
  }

  // ===== Procedural asteroid =====
  function makeAsteroidShape(seed, verts) {
    // returns array of normalized radius multipliers around circle
    const arr = [];
    let s = seed;
    for (let i = 0; i < verts; i++) {
      s = hash(s + i * 1013904223);
      // slightly biased to avoid super spiky shapes
      const r = 0.78 + ((s % 1000) / 1000) * 0.44; // ~[0.78..1.22]
      arr.push(r);
    }
    return arr;
  }

  function spawnAsteroid() {
    const w = canvas.width / canvas._dpr;
    const h = canvas.height / canvas._dpr;

    // spawn outside one random edge
    const edge = Math.floor(rand(0, 4));
    let x, y;
    const margin = 60;
    if (edge === 0) { x = rand(-margin, w + margin); y = -margin; }
    if (edge === 1) { x = w + margin; y = rand(-margin, h + margin); }
    if (edge === 2) { x = rand(-margin, w + margin); y = h + margin; }
    if (edge === 3) { x = -margin; y = rand(-margin, h + margin); }

    // aim generally across the stage (slightly toward center for tension)
    const cx = w * 0.5;
    const cy = h * 0.5;
    const toCenter = Math.atan2(cy - y, cx - x);
    const dir = toCenter + rand(-0.9, 0.9);

    const size = rand(18, 72); // very varied
    const speed = rand(55, 165) * (0.9 + (72 / size) * 0.25); // smaller usually a bit faster

    const seed = (Math.random() * 1e9) | 0;
    const verts = Math.floor(rand(8, 14));
    const shape = makeAsteroidShape(seed, verts);

    state.asteroids.push({
      x, y,
      vx: Math.cos(dir) * speed,
      vy: Math.sin(dir) * speed,
      r: size,
      verts,
      shape,
      rot: rand(0, TAU),
      rotSpd: rand(-1.2, 1.2),
      seed,
      alive: true,
      // approximate collision radius
      hitR: size * 0.88,
    });
  }

  // ===== Bullets / particles =====
  function shoot() {
    const w = canvas.width / canvas._dpr;
    const h = canvas.height / canvas._dpr;
    const s = state.ship;
    const cx = w * 0.5;
    const cy = h * 0.5;

    const muzzle = s.radius + 10;
    const px = cx + Math.cos(s.angle) * muzzle;
    const py = cy + Math.sin(s.angle) * muzzle;

    const speed = 620; // fast, crisp

    state.bullets.push({
      x: px, y: py,
      vx: Math.cos(s.angle) * speed,
      vy: Math.sin(s.angle) * speed,
      life: 0,
      maxLife: 1.1,
      // trail points
      tx: px, ty: py,
    });
  }

  function explode(x, y, baseR) {
    // white-line particle burst
    const count = Math.floor(clamp(baseR * 0.65, 10, 44));
    for (let i = 0; i < count; i++) {
      const a = rand(0, TAU);
      const sp = rand(80, 520) * (0.65 + Math.random() * 0.7);
      const len = rand(6, 24);
      state.particles.push({
        x, y,
        vx: Math.cos(a) * sp,
        vy: Math.sin(a) * sp,
        life: 0,
        maxLife: rand(0.25, 0.65),
        len,
      });
    }
  }

  // ===== Collision =====
  function dist2(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
  }

  // ===== Update / draw =====
  function update(dt) {
    const w = canvas.width / canvas._dpr;
    const h = canvas.height / canvas._dpr;

    state.t += dt;

    // ship rotation physics (smooth: accel + damping)
    const s = state.ship;
    const left = keys.has('ArrowLeft');
    const right = keys.has('ArrowRight');
    let input = 0;
    if (left) input -= 1;
    if (right) input += 1;

    // integrate angular velocity
    s.angVel += input * s.rotAcc * dt;
    // exponential-ish damping
    s.angVel *= Math.exp(-s.rotDamp * dt);
    s.angle += s.angVel * dt;

    // auto-fire (constant shooting)
    s.fireTimer += dt;
    const interval = 1 / s.fireRate;
    while (!state.gameOver && s.fireTimer >= interval) {
      s.fireTimer -= interval;
      shoot();
    }

    // spawn asteroids with gentle difficulty ramp
    state.spawnTimer += dt;
    // over time, spawn a bit faster + allow a few more concurrent
    state.spawnEvery = clamp(lerp(0.85, 0.45, Math.min(1, state.t / 70)), 0.42, 0.9);
    state.maxAsteroids = Math.floor(lerp(10, 18, Math.min(1, state.t / 80)));

    while (!state.gameOver && state.spawnTimer >= state.spawnEvery) {
      state.spawnTimer -= state.spawnEvery;
      if (state.asteroids.length < state.maxAsteroids) spawnAsteroid();
    }

    // bullets
    for (let i = state.bullets.length - 1; i >= 0; i--) {
      const b = state.bullets[i];
      b.life += dt;
      // keep a short trail endpoint (previous position)
      b.tx = b.x;
      b.ty = b.y;
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // remove if out of bounds or expired
      const pad = 80;
      if (b.life > b.maxLife || b.x < -pad || b.x > w + pad || b.y < -pad || b.y > h + pad) {
        state.bullets.splice(i, 1);
      }
    }

    // asteroids
    for (let i = state.asteroids.length - 1; i >= 0; i--) {
      const a = state.asteroids[i];
      a.x += a.vx * dt;
      a.y += a.vy * dt;
      a.rot += a.rotSpd * dt;

      // remove when far out
      const pad = 140;
      if (a.x < -pad || a.x > w + pad || a.y < -pad || a.y > h + pad) {
        state.asteroids.splice(i, 1);
      }
    }

    // particles
    for (let i = state.particles.length - 1; i >= 0; i--) {
      const p = state.particles[i];
      p.life += dt;
      // slightly damp velocity for a nice bloom
      const damp = Math.exp(-3.4 * dt);
      p.vx *= damp;
      p.vy *= damp;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      if (p.life >= p.maxLife) state.particles.splice(i, 1);
    }

    // collisions: bullets vs asteroids
    // (brute-force is fine for these counts)
    for (let ai = state.asteroids.length - 1; ai >= 0; ai--) {
      const a = state.asteroids[ai];
      const hr2 = (a.hitR) * (a.hitR);
      let hit = false;
      for (let bi = state.bullets.length - 1; bi >= 0; bi--) {
        const b = state.bullets[bi];
        if (dist2(a.x, a.y, b.x, b.y) <= hr2) {
          // remove bullet
          state.bullets.splice(bi, 1);
          hit = true;
          break;
        }
      }
      if (hit) {
        explode(a.x, a.y, a.r);
        state.asteroids.splice(ai, 1);
      }
    }

    // ship collision (one life)
    if (!state.gameOver) {
      const cx = w * 0.5;
      const cy = h * 0.5;
      const shipR = state.ship.radius;
      const shipR2 = shipR * shipR;

      for (let ai = 0; ai < state.asteroids.length; ai++) {
        const a = state.asteroids[ai];
        const rr = (a.hitR + shipR * 0.85);
        if (dist2(cx, cy, a.x, a.y) <= rr * rr) {
          explode(cx, cy, 55);
          gameOver();
          break;
        }
      }
    }
  }

  function draw() {
    const dpr = canvas._dpr || 1;
    const w = canvas.width / dpr;
    const h = canvas.height / dpr;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // background
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, w, h);

    // subtle star dust
    // (cheap, deterministic-ish, no state)
    const starCount = Math.floor((w * h) / 30000);
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = '#fff';
    for (let i = 0; i < starCount; i++) {
      const x = (Math.sin(i * 999 + 1.23) * 0.5 + 0.5) * w;
      const y = (Math.sin(i * 2222 + 4.56) * 0.5 + 0.5) * h;
      const s = (Math.sin(i * 7777 + 0.1) * 0.5 + 0.5) * 1.2 + 0.2;
      ctx.fillRect(x, y, s, s);
    }
    ctx.globalAlpha = 1;

    // bullets (with traces)
    ctx.strokeStyle = '#fff';
    for (const b of state.bullets) {
      const t = b.life / b.maxLife;
      const trail = 18 + 22 * (1 - t);
      const dx = b.x - b.tx;
      const dy = b.y - b.ty;
      const mag = Math.hypot(dx, dy) || 1;
      const ux = dx / mag;
      const uy = dy / mag;

      ctx.globalAlpha = 0.95;
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(b.x - ux * trail, b.y - uy * trail);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();

      // tip dot
      ctx.globalAlpha = 1;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(b.x, b.y, 1.7, 0, TAU);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // particles
    for (const p of state.particles) {
      const t = clamp(p.life / p.maxLife, 0, 1);
      const a = 1 - t;
      ctx.globalAlpha = a;
      ctx.lineWidth = 1.4;
      const ang = Math.atan2(p.vy, p.vx);
      const x2 = p.x - Math.cos(ang) * p.len;
      const y2 = p.y - Math.sin(ang) * p.len;
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(p.x, p.y);
      ctx.strokeStyle = '#fff';
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // asteroids
    for (const a of state.asteroids) {
      ctx.save();
      ctx.translate(a.x, a.y);
      ctx.rotate(a.rot);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < a.verts; i++) {
        const ang = (i / a.verts) * TAU;
        const rr = a.r * a.shape[i];
        const x = Math.cos(ang) * rr;
        const y = Math.sin(ang) * rr;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();

      // tiny inner detail line
      ctx.globalAlpha = 0.25;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(-a.r * 0.35, -a.r * 0.1);
      ctx.lineTo(a.r * 0.15, a.r * 0.22);
      ctx.stroke();
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    // ship (center)
    const cx = w * 0.5;
    const cy = h * 0.5;
    const s = state.ship;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(s.angle);

    // ship body - simple triangle with a notch
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(20, 0);
    ctx.lineTo(-14, -12);
    ctx.lineTo(-6, 0);
    ctx.lineTo(-14, 12);
    ctx.closePath();
    ctx.stroke();

    // faint engine line
    ctx.globalAlpha = 0.35;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-14, 0);
    ctx.lineTo(-26, 0);
    ctx.stroke();
    ctx.globalAlpha = 1;

    ctx.restore();

    // game over vignette
    if (state.gameOver) {
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 1;
    }
  }

  function tick(now) {
    const dt = clamp((now - state.last) / 1000, 0, 0.033); // cap for stability
    state.last = now;

    if (!state.gameOver) update(dt);
    else {
      // still update particles for a pleasant finish
      // (no ship/bullets/asteroids updates)
      for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        p.life += dt;
        const damp = Math.exp(-3.4 * dt);
        p.vx *= damp;
        p.vy *= damp;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.life >= p.maxLife) state.particles.splice(i, 1);
      }
    }

    draw();
    requestAnimationFrame(tick);
  }

  reset();
  requestAnimationFrame((t) => { state.last = t; requestAnimationFrame(tick); });
})();
</script>
</body>
</html>
